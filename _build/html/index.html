

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DMTN-098: Options for Generating Unique IDs in the LSST Gen3 Butler Registry</title>
  

  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  

  
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="DMTN-098: Options for Generating Unique IDs in the LSST Gen3 Butler Registry" href="#"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background-color: #343131">
          

          <a href="https://www.lsst.org">
            <img src="_static/lsst-logo-dark.svg" class="logo" />

            <span class="project-title">DMTN-098: Options for Generating Unique IDs in the LSST Gen3 Butler Registry</span>
          </a>

          <ul class="edition-switcher">
            <li>Edition: </li>
            <li><a href="../v">Switch editions</a></li>
            
            <li><a href="https://github.com/lsst-dm/dmtn-098/blob//index.rst">Edit on GitHub</a></li>
            
          </ul>

          

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <!-- Local TOC -->
                <div class="local-toc"><ul>
<li><a class="reference internal" href="#">1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference internal" href="#description-of-id-generation-methods">2&nbsp;&nbsp;&nbsp;Description of ID generation methods</a></li>
<li><a class="reference internal" href="#description-of-tests-performed">3&nbsp;&nbsp;&nbsp;Description of tests performed</a></li>
<li><a class="reference internal" href="#test-results-and-discussion">4&nbsp;&nbsp;&nbsp;Test results and discussion</a></li>
<li><a class="reference internal" href="#supporting-scripts">5&nbsp;&nbsp;&nbsp;Supporting scripts</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">DMTN-098: Options for Generating Unique IDs in the LSST Gen3 Butler Registry</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="dd-masthead">
  <h1 class="dd-title">DMTN-098: Options for Generating Unique IDs in the LSST Gen3 Butler Registry</h1>
  <ul class="dd-authors">
    
      
        <li class="dd-authors-item">Chris Stephens</li>
      
    
  </ul>
  <p>Latest Revision: <a href="#change-record">2018-10-30</a></p>
</div>
           <div itemprop="articleBody">
            
  <div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>This technote is not yet published.</strong></p>
</div>
<div class="section" id="overview">
<h1>1&nbsp;&nbsp;&nbsp;Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>In the <a class="reference external" href="https://dmtn-073.lsst.io">Gen3 Butler Registry</a> (<a class="reference external" href="https://jira.lsstcorp.org/browse/RFC-484">RFC-484</a>), IDs must be unique not only within
a schema but across multiple schemas. This is because the design
requires the union of tables across multiple schemas to search across
multiple sources of data. Additionally, the key generation method must be able to maintain
uniqueness whether the application is online or offline.</p>
<p><strong>Examples of Gen3 Butler usage requiring universally unique IDs:</strong></p>
<ul class="simple">
<li>Data Backbone may do ingestions at any endpoint and must
not depend upon a particular endpoint being available to
generate unique IDs for all endpoints.</li>
<li>Staff may want to use data from the Observatory Operations
Data Service and the Data Backbone in the same task.</li>
<li>Users may generate their own data in their own Registry and
want to use it and Data Backbone data in the same task.</li>
<li>Users may generate their own data in their own Registry and
want to share with other users.</li>
</ul>
<p>This document describes performance and scalability findings for three
candidate key generation methods used to support the universally unique
IDs requirement for the Gen3 Butler application.</p>
<p>Based on these findings, we recommend that the two-column database generated
key method be used. This option scales as well or better than any other option
and is least likely to cause additional issues for the application.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the following discussions, there are references to a
<strong>merge</strong> process.   Merge takes data from one source Registry (say
inside a compute job) and loads it into another destination
Registry (making IDs unique when necessary)</p>
</div>
</div></blockquote>
</div>
<div class="section" id="description-of-id-generation-methods">
<h1>2&nbsp;&nbsp;&nbsp;Description of ID generation methods<a class="headerlink" href="#description-of-id-generation-methods" title="Permalink to this headline">¶</a></h1>
<div class="section" id="registry-software-generates-uuid1-key-values">
<h2>2.1&nbsp;&nbsp;&nbsp;Registry software generates UUID1 key values.<a class="headerlink" href="#registry-software-generates-uuid1-key-values" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Pros:<ol class="arabic">
<li>Does not rely on any database implementation for key generation.</li>
<li>Merge is just (bulk) inserts as IDs are already unique.</li>
</ol>
</li>
<li>Cons:<ol class="arabic">
<li>UUID1 values are dependent on the hardware used to generate the IDs. Values
are pseudo sequential with some chance of duplicate values being generated by
separate processes running on the same hardware at the same time.</li>
<li>The sequential nature of the values results in block contention with enough
concurrent sessions and insertion rates.</li>
</ol>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="registry-software-generates-uuid4-key-values">
<h2>2.2&nbsp;&nbsp;&nbsp;Registry software generates UUID4 key values.<a class="headerlink" href="#registry-software-generates-uuid4-key-values" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Pros:<ol class="arabic">
<li>Does not rely on any database implementation for key generation.</li>
<li>Merge is just (bulk) inserts as IDs are already unique.</li>
<li>UUID4 are completely random. Duplicate values are not a concern.</li>
</ol>
</li>
<li>Cons:<ol class="arabic">
<li>Due to the randomness of the values, UUID4 primary key maintenance increasingly
becomes an issue as table and index size continue to grow relative to the size
of the SGA.</li>
</ol>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="registry-uses-local-database-sequences">
<h2>2.3&nbsp;&nbsp;&nbsp;Registry uses local database sequences.<a class="headerlink" href="#registry-uses-local-database-sequences" title="Permalink to this headline">¶</a></h2>
<p>A database sequence is the usual method to generate unique IDs for
use within a database.  However, a sequence alone will not meet the universally unique
ID requirement across all Butler repositories as there cannot be a central source of
sequence values. A universally unique ID can be generated with the combination of local
database sequences and an ingestion site ID that uniquely identifies each Gen3 Butler
repository.</p>
<p>We considered several different approaches to implementing this.  The most obvious
implementation stores these IDs as a two-column primary key. Other implementations
store these IDs as a single column value.</p>
<p>The variations in using local database sequences and site IDs for key generation all have
similar pros and cons with respect to performance and scalability of database activity.
Because of this, only one test is shown for this class of key generation methods
(SEQ=two columns). Where relevant, differences will be noted in the “Test results and
discussion” section of this document.</p>
<blockquote>
<div><ul class="simple">
<li>Pros:<ol class="arabic">
<li>Inserts perform better even when tables are large.</li>
</ol>
</li>
<li>Cons:<ol class="arabic">
<li>Keeping site IDs unique is mostly policy. Some IDs would be
reserved for the Data Backbone endpoints.</li>
<li>Merge becomes more complicated in batch jobs to minimize site IDs
for a particular endpoint or user.  IDs in the source registry must
be updated to appropriate IDs in the destination registry.</li>
<li>As insertion rates and concurrency increase, blocks become “hot” and sessions
begin to wait to acquire locks and latches used to manage concurrency.</li>
</ol>
</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also considered was an External Generator of Unique IDs. This was not
included as part of the testing because Gen3 Butler requires the ability to
perform registry inserts without an internet connection.</p>
</div>
</div>
</div>
<div class="section" id="description-of-tests-performed">
<h1>3&nbsp;&nbsp;&nbsp;Description of tests performed<a class="headerlink" href="#description-of-tests-performed" title="Permalink to this headline">¶</a></h1>
<p>All tests were performed on a 3-node Oracle 12.2.0.1 RAC database with a 4GB SGA per
instance. Each instance is running on a server with 20 Intel(R) Xeon(R) CPU E5-2650
v3 &#64; 2.30GHz cores and 128GB of RAM. The database instances were purposely made small
to highlight differences in key generation methods.</p>
<p>Separate tables were created for each ID generation method. Each table was seeded with
approximately 20 million rows.  The initial seeding of data was necessary to demonstrate the
scalability issues inherent with UUID4 based IDs.</p>
<p>Database DDL <a class="reference internal" href="#database-ddl-sql">database_ddl.sql</a></p>
<p>Each ID generation method was tested by calling a bash script to run 30 concurrent jobs of
the $1 supplied python script.  Each python script generates 10,000 inserts utilizing its
respective key generation method.</p>
<pre class="highlight"><style type="text/css">
span.prompt1:before {
  content: "$ ";
}
</style><span class="prompt1">./test_harness.sh uuid1_inserts.py</span>
<span class="prompt1">./test_harness.sh uuid4_inserts.py</span>
<span class="prompt1">./test_harness.sh seq_inserts.py</span>
</pre><p>Bash control script <a class="reference internal" href="#test-harness-sh">test_harness.sh</a></p>
<p>UUID1 key generation script <a class="reference internal" href="#uuid1-inserts-py">uuid1_inserts.py</a></p>
<p>UUID4 key generation script <a class="reference internal" href="#uuid4-inserts-py">uuid4_inserts.py</a></p>
<p>SEQ key generation script <a class="reference internal" href="#seq-inserts-py">seq_inserts.py</a></p>
</div>
<div class="section" id="test-results-and-discussion">
<h1>4&nbsp;&nbsp;&nbsp;Test results and discussion<a class="headerlink" href="#test-results-and-discussion" title="Permalink to this headline">¶</a></h1>
<p>Active session history data was collected for each key generation method that was tested.
Tanel Poder’s <a class="reference external" href="https://github.com/tanelpoder/tpt-oracle/blob/master/ash/ashtop.sql">ashtop.sql</a> script was used to highlight differences in the workload profile
for each method.</p>
<p>Of primary concern is the total time taken to complete each test. The output below
clearly shows the UUID4 approach takes significantly more time to complete
than the other two methods.</p>
<p>SQL&gt; &#64;ashtop module “module in (‘SEQ’,’UUID1’,’UUID4’)” sysdate-1 sysdate</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Seconds</th>
<th class="head">MODULE</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2033</td>
<td>UUID4</td>
</tr>
<tr class="row-odd"><td>397</td>
<td>UUID1</td>
</tr>
<tr class="row-even"><td>220</td>
<td>SEQ</td>
</tr>
</tbody>
</table>
<p>The following output breaks down the total time for each test by instrumented wait event
per database object. More detailed discussion follows the output below but you can see that
database work involving index maintenance accounts for most of the processing time
regardless of key generation method.</p>
<p>SQL&gt; &#64;ashtop event2,objt “module = ‘UUID4’” sysdate-1 sysdate</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="56%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Seconds</th>
<th class="head">%This</th>
<th class="head">EVENT2</th>
<th class="head">OBJT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1975</td>
<td>97%</td>
<td>db file sequential read</td>
<td>UUID4_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>29</td>
<td>1%</td>
<td>ON CPU</td>
<td>UUID4_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>12</td>
<td>1%</td>
<td>gc current grant 2-way</td>
<td>UUID4_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>0%</td>
<td>db file scattered read</td>
<td>UUID4_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>5</td>
<td>0%</td>
<td>gc buffer busy acquire [data block]</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>0%</td>
<td>read by other session</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>ON CPU</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>db file scattered read</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>db file sequential read</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>gc current multi block request</td>
<td>UUID4 [TABLE]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>read by other session</td>
<td>UUID4_PK [INDEX]</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>11 rows selected.</p>
<p>SQL&gt; &#64;ashtop event2,objt “module = ‘UUID1’” sysdate-1 sysdate</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="56%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Seconds</th>
<th class="head">%This</th>
<th class="head">EVENT2</th>
<th class="head">OBJT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>180</td>
<td>45%</td>
<td>buffer busy waits [data block]</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>91</td>
<td>23%</td>
<td>read by other session</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>45</td>
<td>11%</td>
<td>ON CPU</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>43</td>
<td>11%</td>
<td>enq: TX - index contention</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>20</td>
<td>5%</td>
<td>gc buffer busy acquire [data block]</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>2%</td>
<td>latch: ges resource hash list</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>6</td>
<td>2%</td>
<td>db file sequential read</td>
<td>UUID1_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>ON CPU</td>
<td>UUID1 [TABLE]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>db file scattered read</td>
<td>UUID1 [TABLE]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>db file sequential read</td>
<td>UUID1 [TABLE]</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>SQL&gt; &#64;ashtop event2,objt “module = ‘SEQ’” sysdate-1 sysdate</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="9%" />
<col width="47%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Seconds</th>
<th class="head">%This</th>
<th class="head">EVENT2</th>
<th class="head">OBJT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>92</td>
<td>42%</td>
<td>buffer busy waits [data block]</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>60</td>
<td>27%</td>
<td>ON CPU</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>38</td>
<td>17%</td>
<td>enq: TX - index contention</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>16</td>
<td>7%</td>
<td>latch: ges resource hash list</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>6</td>
<td>3%</td>
<td>library cache: mutex X</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>2%</td>
<td>ON CPU</td>
<td>SEQ [TABLE]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>buffer busy waits [data block]</td>
<td>SEQ [TABLE]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>buffer deadlock</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-even"><td>1</td>
<td>0%</td>
<td>enq: FB - contention</td>
<td>SEQ_PK [INDEX]</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>0%</td>
<td>latch: ges resource hash list</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Not shown are workload profiles for each key generation test with minimal existing data in target tables.
Those tests showed UUID4 to be faster than the other two methods. This is due to the randomness of the key values
preventing “hot” blocks from being an issue during index maintenance. Inserts are spread across all the blocks
in the index.</p>
<p>However, once enough data accumulates in the UUID4 table relative to SGA size, PK index blocks needed for
inserts are less and less likely to be found in cache. A tipping point is eventually reached and the UUID4
workload profile becomes dominated by physical I/O. As shown in the output above 97% of database time was
associated with “db file sequential read” physical I/O wait event causing the UUID4 test to take more than
four times as long as the other two methods to complete when target tables have approximately 20 million
preexisting rows. This problem continues to get worse as data accumulates preventing the UUID4 method from
scaling. This also has negative performance side effects for simultaneous database activity since the cache is
constantly being filled with index blocks needed for UUID4 key maintenance. Due to UUID4 key generation’s lack of
scalability and negative side effects on other concurrent workloads we don’t recommend this option.</p>
<p>UUID1 and database key generation methods do not suffer from the same physical I/O and scalability problems as UUID4
but do suffer from concurrency issues associated with “hot” blocks. When sessions aren’t on CPU
getting work done, they are waiting for concurrency controls to be released by other sessions for the index blocks
that need modification.  These concurrency issues are independent of existing table and index size and can be
alleviated to some extent with well-known techniques including hash partitioned indexes, “pctfree” index attribute,
“minimize records_per_block” table attribute, per instance sequence caching, and possibly Oracle’s new scalable
sequence type.</p>
<p>UUID1 key generation suffers from the possibility of duplicate values produced by separate processes running on
the same hardware generating values at the same time. Duplicate keys were generated on three occasions during
performance testing. It’s for this reason we don’t recommend the use of UUID1 based keys.</p>
<p>The requirements of Gen3 Butler application mandate universally unique IDs across all repositories. We can satisfy
this requirement by allocating unique site IDs so that keys can be maintained independently at each site. The
combination of the two satisfies universal uniqueness.</p>
<p>There was additional discussion on whether to implement the local database sequence and site ID as a single column or
two-column primary key.</p>
<p>One single column implementation uses the decimal portion of a number datatype to designate a static site ID for each
Butler repository and bytes to the left of the decimal point for sequence generated uniqueness within sites. This strategy
was abandoned because of concerns associated with implicit rounding while values are passed between variables in different
programming languages. This method also violates first normal form and requires extra interpretation to extract the full
meaning of the value.</p>
<p>Another single column implementation converts sequence and fixed width site ID values to string datatype, appends the two
together, and converts back to a number.  While this works logically, there is unnecessary overhead during datatype
conversion and it offers no real advantage over the two column implementation. As with the previous method, this violates
first normal form. We do not recommend this option.</p>
<p>Finally, the two-column database generated approach was considered. This solution does not suffer from the performance
overhead, rounding concerns, or violation of database normalization that the other database ID generation methods do.
It is, however, the option that requires the most development work to accommodate the merge process.</p>
</div>
<div class="section" id="supporting-scripts">
<h1>5&nbsp;&nbsp;&nbsp;Supporting scripts<a class="headerlink" href="#supporting-scripts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="database-ddl">
<span id="database-ddl-sql"></span><h2>5.1&nbsp;&nbsp;&nbsp;Database DDL<a class="headerlink" href="#database-ddl" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">create</span> <span class="n">table</span> <span class="n">uuid1</span> 
   <span class="p">(</span><span class="n">pk_col</span> <span class="n">raw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="ow">not</span> <span class="n">null</span> <span class="n">enable</span><span class="p">,</span> 
    <span class="n">uuid</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">128</span> <span class="n">byte</span><span class="p">),</span> 
    <span class="n">constraint</span> <span class="n">uuid1_pk</span> <span class="n">primary</span> <span class="n">key</span> <span class="p">(</span><span class="n">pk_col</span><span class="p">)</span> <span class="n">using</span> <span class="n">index</span><span class="p">);</span>
    
<span class="n">create</span> <span class="n">table</span> <span class="n">uuid4</span> 
   <span class="p">(</span><span class="n">pk_col</span> <span class="n">raw</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="ow">not</span> <span class="n">null</span> <span class="n">enable</span><span class="p">,</span> 
    <span class="n">uuid</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">128</span> <span class="n">byte</span><span class="p">),</span> 
    <span class="n">constraint</span> <span class="n">uuid4_pk</span> <span class="n">primary</span> <span class="n">key</span> <span class="p">(</span><span class="n">pk_col</span><span class="p">)</span> <span class="n">using</span> <span class="n">index</span><span class="p">);</span>
    
<span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="n">package</span> <span class="n">pkg_butler_id</span> <span class="k">as</span> 
  <span class="n">c_butler_site_id</span> <span class="n">constant</span> <span class="n">number</span> <span class="p">:</span><span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
<span class="n">end</span> <span class="n">pkg_butler_id</span><span class="p">;</span>
<span class="o">/</span>

<span class="n">create</span> <span class="n">table</span> <span class="n">seq</span>
   <span class="p">(</span><span class="n">pk_col1</span> <span class="n">number</span> <span class="ow">not</span> <span class="n">null</span> <span class="n">enable</span><span class="p">,</span> 
    <span class="n">pk_col2</span> <span class="n">number</span> <span class="ow">not</span> <span class="n">null</span> <span class="n">enable</span><span class="p">,</span> 
    <span class="n">uuid</span> <span class="n">varchar2</span><span class="p">(</span><span class="mi">128</span> <span class="n">byte</span><span class="p">),</span> 
    <span class="n">constraint</span> <span class="n">seq_pk</span> <span class="n">primary</span> <span class="n">key</span> <span class="p">(</span><span class="n">pk_col1</span><span class="p">,</span><span class="n">pk_col2</span><span class="p">)</span> <span class="n">using</span> <span class="n">index</span><span class="p">);</span>

<span class="n">create</span> <span class="n">sequence</span>  <span class="n">seq_seq1</span> 
  <span class="n">increment</span> <span class="n">by</span> <span class="mi">1</span> 
  <span class="n">start</span> <span class="k">with</span> <span class="mi">1</span> <span class="n">cache</span> <span class="mi">1000</span> 
  <span class="n">noorder</span>  <span class="n">nocycle</span>  <span class="n">nokeep</span>  <span class="n">noscale</span>  <span class="k">global</span> <span class="p">;</span>

<span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="n">package</span> <span class="n">pkg_butler_id</span> <span class="k">as</span> 
  <span class="n">c_butler_site_id</span> <span class="n">constant</span> <span class="n">number</span> <span class="p">:</span><span class="o">=</span> <span class="mi">9999</span><span class="p">;</span>
<span class="n">end</span> <span class="n">pkg_butler_id</span><span class="p">;</span>

<span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="n">trigger</span> <span class="n">seq_trg</span> 
<span class="n">before</span> <span class="n">insert</span> <span class="n">on</span> <span class="n">seq</span> 
<span class="k">for</span> <span class="n">each</span> <span class="n">row</span> 
<span class="n">begin</span>
  <span class="o">&lt;&lt;</span><span class="n">column_sequences</span><span class="o">&gt;&gt;</span>
  <span class="n">begin</span>
    <span class="k">if</span> <span class="n">inserting</span> <span class="ow">and</span> <span class="p">:</span><span class="n">new</span><span class="o">.</span><span class="n">pk_col1</span> <span class="ow">is</span> <span class="n">null</span> <span class="n">then</span>
      <span class="n">select</span> <span class="n">pkg_butler_id</span><span class="o">.</span><span class="n">c_butler_site_id</span><span class="p">,</span> <span class="n">seq_seq1</span><span class="o">.</span><span class="n">nextval</span> 
        <span class="n">into</span> <span class="p">:</span><span class="n">new</span><span class="o">.</span><span class="n">pk_col1</span><span class="p">,</span> <span class="p">:</span><span class="n">new</span><span class="o">.</span><span class="n">pk_col2</span> 
        <span class="kn">from</span> <span class="nn">sys.dual</span><span class="p">;</span>
    <span class="n">end</span> <span class="k">if</span><span class="p">;</span>
  <span class="n">end</span> <span class="n">column_sequences</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>
<span class="o">/</span>

<span class="n">alter</span> <span class="n">trigger</span> <span class="n">seq_trg</span> <span class="n">enable</span><span class="p">;</span>

</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="tesh-harness-bash-script">
<span id="test-harness-sh"></span><h2>5.2&nbsp;&nbsp;&nbsp;Tesh harness bash script<a class="headerlink" href="#tesh-harness-bash-script" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/bin/bash

for i in {1..30}
do
  $1 &amp; &gt; /dev/null 2&gt;1
done
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="uuid1-inserts-py">
<span id="id1"></span><h2>5.3&nbsp;&nbsp;&nbsp;UUID1_inserts.py<a class="headerlink" href="#uuid1-inserts-py" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">cx_Oracle</span>

<span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;insert into uuid1(pk_col, uuid) values (:uuid1, :uuid1)&quot;</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;/@lsst_id_test&quot;</span><span class="p">)</span>
<span class="n">connection</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s2">&quot;UUID1&quot;</span>
<span class="n">connection</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;UUID30x10000&quot;</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span><span class="n">uuid1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="uuid4-inserts-py">
<span id="id2"></span><h2>5.4&nbsp;&nbsp;&nbsp;UUID4_inserts.py<a class="headerlink" href="#uuid4-inserts-py" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">cx_Oracle</span>

<span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;insert into uuid4(pk_col, uuid) values (:uuid4, :uuid4)&quot;</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;/@lsst_id_test&quot;</span><span class="p">)</span>
<span class="n">connection</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s2">&quot;UUID4&quot;</span>
<span class="n">connection</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;UUID4_30x10000&quot;</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span><span class="n">uuid4</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="seq-inserts-py">
<span id="id3"></span><h2>5.5&nbsp;&nbsp;&nbsp;SEQ_inserts.py<a class="headerlink" href="#seq-inserts-py" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">cx_Oracle</span>

<span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;insert into seq(uuid) values (:uuid4)&quot;</span>

<span class="n">connection</span> <span class="o">=</span> <span class="n">cx_Oracle</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;/@lsst_id_test&quot;</span><span class="p">)</span>
<span class="n">connection</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s2">&quot;SEQ&quot;</span>
<span class="n">connection</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="s2">&quot;SEQ_30x10000&quot;</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="n">dummy_uid</span> <span class="o">=</span> <span class="s1">&#39;d79ec82f952243529d9a2d09be9f7ed9&#39;</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span><span class="n">uuid4</span><span class="o">=</span><span class="n">dummy_uid</span><span class="p">)</span>

<span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, LSST.
      Last updated on Oct 30, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

  

   <script type="text/javascript" src="_static/js/theme.js"></script>

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>